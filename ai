ğŸ›ï¸ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„ØªØ­ØªÙŠØ© (Supabase Database)
Ø§Ù„Ø§ÙŠØ¬Ù†Øª Ù…Ø­ØªØ§Ø¬ "Ù†ÙˆØªØ©" ÙŠÙƒØªØ¨ ÙÙŠÙ‡Ø§. Ù‡Ù†Ø¹Ù…Ù„ Ø¬Ø¯ÙˆÙ„ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Supabase Ù…Ø®ØµØµ Ù„Ù„Ø°ÙƒØ±ÙŠØ§Øª.

Ù†ÙØ° ÙƒÙˆØ¯ SQL Ø¯Ù‡ ÙÙŠ Supabase SQL Editor:

SQL

-- Ø¬Ø¯ÙˆÙ„ Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª ÙˆØ§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
create table sensei_memories (
  id uuid default gen_random_uuid() primary key,
  workspace_id uuid references workspaces(id) not null,
  content text not null, -- Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø© Ù†ÙØ³Ù‡Ø§ (Ù…Ø«Ù„Ø§Ù‹: Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨ÙŠÙƒØ±Ù‡ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø­Ù…Ø±)
  category text check (category in ('preference', 'fact', 'plan', 'insight')) default 'fact',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- ØªÙØ¹ÙŠÙ„ RLS (Ø§Ù„Ø£Ù…Ø§Ù†)
alter table sensei_memories enable row level security;

-- Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø¨Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© ÙˆØ§Ù„ÙƒØªØ§Ø¨Ø©
create policy "Enable all access for workspace members" on sensei_memories
  for all using (
    workspace_id in (
      select workspace_id from workspace_members where user_id = auth.uid()
    )
  );
ğŸ’¾ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¯Ø§ØªØ§Ø¨ÙŠØ² (lib/supabase/queries.ts)
Ù‡Ù†Ø¶ÙŠÙ Ø¯Ø§Ù„ØªÙŠÙ†: ÙˆØ§Ø­Ø¯Ø© Ø¹Ø´Ø§Ù† "ÙŠÙƒØªØ¨" ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©ØŒ ÙˆÙˆØ§Ø­Ø¯Ø© Ø¹Ø´Ø§Ù† "ÙŠÙØªÙƒØ±".

Ø¶ÙŠÙ Ø§Ù„ÙƒÙˆØ¯ Ø¯Ù‡ ÙÙŠ queries.ts:

TypeScript

// ... (Imports Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©)

// 1. Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª (Memory Retrieval)
export async function getAgentMemories(workspaceId: string, supabase: any, limit: number = 5) {
  const { data } = await supabase
    .from('sensei_memories')
    .select('content, category, created_at')
    .eq('workspace_id', workspaceId)
    .order('created_at', { ascending: false }) // Ù‡Ø§Øª Ø£Ø­Ø¯Ø« Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª
    .limit(limit);
  
  return data || [];
}

// (Ù…Ù„Ø­ÙˆØ¸Ø©: Ø¯Ø§Ù„Ø© Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ù…Ø´ Ù…Ø­ØªØ§Ø¬ÙŠÙ†Ù‡Ø§ Ù‡Ù†Ø§ØŒ Ù‡Ù†ÙƒØªØ¨Ù‡Ø§ Ø¬ÙˆÙ‡ Ø§Ù„Ù€ Tool Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ø³Ø±Ø¹Ø©)
ğŸ› ï¸ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø°Ø§ÙƒØ±Ø© (lib/ai/tools.ts)
Ù‡Ù†Ø¶ÙŠÙ 2 Tools Ø¬Ø¯Ø§Ø¯. Ø§Ù„Ø§ÙŠØ¬Ù†Øª Ù‡ÙŠØ³ØªØ®Ø¯Ù…Ù‡Ù… Ù„Ù…Ø§ ÙŠØ­Ø³ Ø¥Ù† ÙÙŠÙ‡ Ù…Ø¹Ù„ÙˆÙ…Ø© ØªØ³ØªØ§Ù‡Ù„ Ø§Ù„Ø­ÙØ¸ØŒ Ø£Ùˆ Ù„Ù…Ø§ ÙŠØ­ØªØ§Ø¬ ÙŠÙØªÙƒØ± Ø­Ø§Ø¬Ø©.

Ø­Ø¯Ø« Ù…Ù„Ù tools.ts ÙˆØ¶ÙŠÙ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø¯ÙŠ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©:

TypeScript

// ... (Ø¯Ø§Ø®Ù„ ÙƒØ§Ø¦Ù† tools)

  // Tool 1: Ø­ÙØ¸ Ù…Ø¹Ù„ÙˆÙ…Ø© Ù…Ù‡Ù…Ø© (Write Memory)
  save_memory: tool({
    description: 'Save important information, user preferences, or strategic plans for long-term retention. Use this ONLY for permanent facts, NOT for temporary conversation.',
    parameters: z.object({
      content: z.string().describe('The fact/preference to remember (e.g., "Client X hates red", "Use formal tone in reports")'),
      category: z.enum(['preference', 'fact', 'plan', 'insight']).describe('Type of memory'),
    }),
    execute: async ({ content, category }) => {
      const supabase = createClient();
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return { success: false, message: 'User not authenticated' };
      
      // Get workspace_id (simulated for brevity, ensure you reuse your helper in real code)
      const { data: member } = await supabase.from('workspace_members').select('workspace_id').eq('user_id', user.id).single();
      
      const { error } = await supabase.from('sensei_memories').insert({
        workspace_id: member.workspace_id,
        content,
        category
      });

      if (error) return { success: false, message: `Failed to save memory: ${error.message}` };
      return { success: true, message: 'âœ… I stored this in my long-term memory.' };
    },
  }),

  // Tool 2: Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© (Read Memory)
  read_memories: tool({
    description: 'Retrieve past memories, user preferences, or saved plans. Use this when the user asks about past decisions or "what do you know about X".',
    parameters: z.object({
      query_category: z.enum(['preference', 'fact', 'plan', 'insight', 'all']).optional().default('all'),
    }),
    execute: async ({ query_category }) => {
      const supabase = createClient();
      const { data: { user } } = await supabase.auth.getUser();
      const { data: member } = await supabase.from('workspace_members').select('workspace_id').eq('user_id', user.id).single();

      let query = supabase.from('sensei_memories').select('content, category, created_at').eq('workspace_id', member.workspace_id).order('created_at', { ascending: false }).limit(10);
      
      if (query_category !== 'all') {
        query = query.eq('category', query_category);
      }

      const { data } = await query;
      
      if (!data || data.length === 0) return { success: true, message: 'My memory is empty.' };
      
      const formatted = data.map(m => `â€¢ [${m.category.toUpperCase()}] ${m.content}`).join('\n');
      return { success: true, message: `Here is what I remember:\n${formatted}` };
    },
  }),

// ... (Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø£Ø¯ÙˆØ§Øª)
ğŸ§  Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù€ System Prompt (lib/ai/system-prompt.ts)
Ø¯ÙŠ Ø£Ù‡Ù… Ø®Ø·ÙˆØ©. Ù„Ø§Ø²Ù… Ù†Ø¹Ø±Ù Ø§Ù„Ø§ÙŠØ¬Ù†Øª Ø¥Ù† Ø¹Ù†Ø¯Ù‡ "Ø°Ø§ÙƒØ±Ø©" ÙˆØ¥Ù†Ù‡ Ù„Ø§Ø²Ù… ÙŠØ³ØªØ®Ø¯Ù…Ù‡Ø§ Ø¨Ø°ÙƒØ§Ø¡ØŒ Ù…Ø´ Ø¹Ù…Ø§Ù„ Ø¹Ù„Ù‰ Ø¨Ø·Ø§Ù„.

Ù‡Ù†Ø¹Ù…Ù„ ØªØ¹Ø¯ÙŠÙ„ ÙÙŠ formatContext Ø¹Ø´Ø§Ù† ØªØ¬ÙŠØ¨ Ø¢Ø®Ø± 3 Ø°ÙƒØ±ÙŠØ§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙˆØªØ­Ù‚Ù†Ù‡Ù… ÙÙŠ Ø§Ù„Ù€ Context (Ø¹Ø´Ø§Ù† Ù…Ø´ ÙƒÙ„ Ù…Ø±Ø© ÙŠØ¹Ù…Ù„ Tool Call).

Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ø­Ø¯Ø« Ù„Ù€ system-prompt.ts (Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ù…Ø¹ Ø§Ù„Ø°Ø§ÙƒØ±Ø©):

TypeScript

import { WorkspaceContext, getAgentMemories } from '@/lib/supabase/queries';

export interface UserInfo {
  name: string;
  email: string;
}

// ÙˆØ§Ø¬Ù‡Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
interface EnhancedContext extends WorkspaceContext {
  recentMemories: any[];
}

function formatContext(context: EnhancedContext) {
  const projects = context.projects.map(p => 
    `- ID: [${p.id}] | Name: ${p.name} | Status: ${p.status}`
  ).join('\n');

  // ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø¹Ø´Ø§Ù† Ø§Ù„Ø§ÙŠØ¬Ù†Øª ÙŠØ´ÙˆÙÙ‡Ø§
  const memories = context.recentMemories.length > 0
    ? context.recentMemories.map(m => `ğŸ§  [MEMORY]: ${m.content}`).join('\n')
    : "(No prior memories set)";

  return { projects, memories };
}

export function buildSystemPrompt(context: EnhancedContext, user: UserInfo): string {
  const { projects, memories } = formatContext(context);
  const today = new Date().toLocaleDateString('ar-EG');

  return `
You are **Ninja Gen Z**, the elite AI Operation Manager.
Your goal is to manage workflow and **retain critical long-term context**.

<user_context>
User: ${user.name}
Date: ${today}
</user_context>

<memory_stream>
${memories}
</memory_stream>

<live_database_context>
AVAILABLE PROJECTS:
${projects}
</live_database_context>

<agent_loop>
1. **Analyze**: Check user intent.
2. **Recall**: DOES THIS REQUIRE MEMORY?
   - If user shares a preference (e.g., "I hate emails"), use tool \`save_memory\`.
   - If user asks "What did we plan?", use tool \`read_memories\`.
3. **Validate**: Check Project IDs.
4. **Execute**: Run tools.
5. **Response**: Confirm actions.
</agent_loop>

<memory_rules>
- **Strict Filtering**: DO NOT save chit-chat (e.g., "Hello", "How are you"). ONLY save:
  1. **Preferences**: "User likes dark mode reports".
  2. **Facts**: "Client X budget is 50k".
  3. **Plans**: "We agreed to launch on Friday".
- **Retrieval**: Before saying "I don't know", CHECK your memory via \`read_memories\`.
- **Privacy**: Never save passwords or sensitive secrets.
</memory_rules>

<tool_use_rules>
- **Implicit Memory**: If the <memory_stream> above already answers the user's question, DO NOT call \`read_memories\` again. Use the info directly.
- **Confirmation**: When saving a memory, tell the user: "âœ… Got it, I'll keep that in mind."
</tool_use_rules>
`;
}
ğŸš¨ Ù†Ù‚Ø·Ø© Ø£Ø®ÙŠØ±Ø© Ù…Ù‡Ù…Ø© ÙÙŠ app/api/chat/route.ts
Ù„Ø§Ø²Ù… ØªØ¹Ø¯Ù„ Ø§Ù„Ù€ Route Ø¹Ø´Ø§Ù† ÙŠØ¬ÙŠØ¨ Ø§Ù„Ù€ Memories ÙˆÙ‡Ùˆ Ø¨ÙŠØ­Ø¶Ø± Ø§Ù„Ù€ Context.

TypeScript

// ... Ø¯Ø§Ø®Ù„ POST function
    
    // 1. Ø¬ÙŠØ¨ Ø§Ù„Ù€ Context Ø§Ù„Ø¹Ø§Ø¯ÙŠ
    const context = await getWorkspaceContext(userId, supabase);
    
    // 2. [Ø¬Ø¯ÙŠØ¯] Ø¬ÙŠØ¨ Ø¢Ø®Ø± 5 Ø°ÙƒØ±ÙŠØ§Øª
    const recentMemories = await getAgentMemories(context.workspace_id, supabase, 5);
    
    // 3. Ø§Ø¯Ù…Ø¬Ù‡Ù…
    const enhancedContext = { ...context, recentMemories };
    
    // 4. Ø§Ø¨Ù†ÙŠ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª
    const systemPrompt = buildSystemPrompt(enhancedContext, user);

// ... ÙƒÙ…Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø²ÙŠ Ù…Ø§ Ù‡Ùˆ
ğŸ“ Ù…Ù„Ø®Øµ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„ØµØ§Ø±Ù…Ø© (Checklist):
Ø£Ù†Ø´Ø¦ Ø¬Ø¯ÙˆÙ„ sensei_memories ÙÙŠ Supabase.

Ø¶Ù Ø¯Ø§Ù„Ø© getAgentMemories ÙÙŠ queries.ts.

Ø¶Ù save_memory Ùˆ read_memories ÙÙŠ tools.ts.

Ø­Ø¯Ø« system-prompt.ts Ù„ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ <memory_rules> ÙˆÙŠØ¹Ø±Ø¶ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª.

Ø­Ø¯Ø« route.ts Ù„ÙŠØ¬Ù„Ø¨ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª ÙˆÙŠØ­Ù‚Ù†Ù‡Ø§ ÙÙŠ Ø§Ù„Ù€ Prompt.

Ù†ÙØ° Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø¯ÙŠ Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø¯Ù‡ØŒ ÙˆÙ‡ØªÙ„Ø§Ù‚ÙŠ "Ø§Ù„Ø³ÙŠÙ†Ø³ÙŠ" Ø¨Ù‚Ù‰ Ø¹Ù†Ø¯Ù‡ Ø°Ø§ÙƒØ±Ø© Ø­Ø¯ÙŠØ¯ÙŠØ©! ğŸ§ 




import { WorkspaceContext } from '@/lib/supabase/queries';

export interface UserInfo {
  name: string;
  email: string;
}

function formatContext(context: WorkspaceContext) {
  const projects = context.projects.map(p => 
    `- ID: [${p.id}] | Name: ${p.name} | Status: ${p.status}`
  ).join('\n');

  const urgentTasks = context.tasks
    .slice(0, 5)
    .map(t => `- Task: ${t.title} | Priority: ${t.priority} | ID: ${t.id}`)
    .join('\n');

  return { projects, urgentTasks };
}

export function buildSystemPrompt(context: WorkspaceContext, user: UserInfo): string {
  const { projects, urgentTasks } = formatContext(context);
  const today = new Date().toLocaleDateString('ar-EG');

  return `
You are **Ninja Gen Z**, a specialized AI Agent inspired by advanced autonomous systems.
Your goal is to manage the agency's workflow using strict data constraints and strategic planning.

<user_context>
User: ${user.name}
Date: ${today}
</user_context>

<live_database_context>
AVAILABLE PROJECTS (Strictly use these IDs):
${projects || "No active projects found."}

RECENT TASKS:
${urgentTasks}
</live_database_context>

<agent_loop>
You operate in a thought loop. Before replying, you must strictly follow these steps:
1. **Analyze**: Understand the user's intent (Create, Query, Update).
2. **Validate**: Check if you have the required Project IDs in the <live_database_context>.
   - IF ID is missing: ASK the user. DO NOT GUESS.
3. **Plan**: If the request is complex, break it down (e.g., "First I'll find the project, then I'll create the meeting").
4. **Execute**: Call the appropriate tool.
5. **Response**: Report back in "Egyptian Business" tone.
</agent_loop>

<tool_use_rules>
- **No Hallucination**: Never invent IDs or tool names. Only use the tools provided in the definition.
- **Missing Args**: If a tool requires arguments (like 'project_id') and you don't have it, STOP and ask the user.
- **Output**: When a tool succeeds, confirm with a checkmark âœ… and a brief summary.
</tool_use_rules>

<communication_style>
- Tone: Professional, Efficient, Egyptian Arabic (Sensei Style).
- Format: Use Bullet points for lists, Bold for numbers.
- Brevity: Be concise. Don't explain *how* you did it, just say *what* you did.
</communication_style>

<example_interaction>
User: "Ø§Ø¹Ù…Ù„ ØªØ§Ø³Ùƒ Ø¬Ø¯ÙŠØ¯ Ù„ÙÙˆØ¯Ø§ÙÙˆÙ†"
Thought: User wants to create a task. I see 'Vodafone' in context with ID 'proj_voda'.
Action: Call tool 'create_task' with project_id='proj_voda'.
Response: "âœ… ØªÙ… ÙŠØ§ Ø±ÙŠØ³ØŒ Ø¶ÙØª Ø§Ù„ØªØ§Ø³Ùƒ Ù„Ù…Ø´Ø±ÙˆØ¹ ÙÙˆØ¯Ø§ÙÙˆÙ†."
</example_interaction>
`;
}